什么时候数据在多线程并发的环境下会存在安全问题呢？
    三个条件
        1. 多线程并发
        2. 有共享数据
        3. 共享数据有修改的行为

如何解决呢？
    在多线程并发的环境下，有共享数据，并且这个数据还会被修改，就可能存在线程安全问题
        如果解决？
            采用排队执行，不能并发
            这种排队机制叫做 线程同步机制 synchronization

    线程排队会牺牲一部分效率，没办法，数据安全第一位，数据第一位才是最重要的

涉及到线程同步这块，就有2个专业术语
    异步编程模型
        线程t1和线程t2，各自执行各自的，谁也不用等谁，叫做异步编程模型

    同步编程模型
        线程t1和线程t2，发生了t1等待t2，或者t2等待t1执行完毕，发生了排队，就是同步编程模型

Java的三大变量
    实例变量：存在堆中
    静态变量：存在方法区中
    局部变量：存在栈当中

    局部变量永远不会出现线程安全问题，因为局部变量不共享，一个线程一个栈；而堆和方法区都只有一个，堆和方法区都只有一个，都有可能出现问题
    就是要保证成员变量的安全问题，成员变量是实例变量和静态变量的统称

synchronized有两种写法
    1. 同步代码块
    2. 在实例方法上使用synchronized
    3. 在静态方法上使用synchronized，表示找类锁。
        类锁永远只有一把，就算创建了100个对象，那类锁也只有一把
        类锁就是为了保证静态变量的安全

Deadlock
    不出现异常，也不会出现错误，程序一直僵持在哪里，这种错误最难调试

聊一聊 我们应该怎么解决线程安全问题呢？
    不是一上来就synchronized的，因为它会让程序的执行效率降低，用户体验不好。
    系统的用户吞吐量降低，用户体验差，在不得已的情况下在选择线程同步机制

    第一种方案：尽量使用局部变量代替成员变量

    第二种方案：如果必须是实例变量，那可以考虑使用创建多个对象，这样实例变量就不共享了，比如100个对象100个线程就ok

    第三种方案：如果不能用局部变量，也没法创建多个对象，那才使用synchronized的线程同步机制

7. 线程还有什么内容？
    1. 守护线程
        Java语言中分为两大类：
            一类：用户线程
            一类：守护线程
            其中具有代表性的就是：垃圾回收线程（守护线程）

        注意：main方法是一个用户线程
        守护线程有一种背后默默行动的感觉，运行在后台，所有用户线程结束了，那么守护线程也自动退出了

        守护线程用在什么地方？
            比如每天00：00的时候，系统自动备份，这个还需要到定时器，可以将定时器设置为守护线程
            如果没有用户线程了，那么守护线程也要退出了
    2. 定时器
        定时器：间隔特定的实际，执行特定的程序
        每周要进行银行账户的总账操作
        每天要进行数据的备份操作

            可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务。
            这种方式是最原始的定时器。（比较low）

            在java的类库中已经写好一个定时器：java.util.Timer,可以直接拿来用。
            不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持
            定时任务的。

            在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，
            这个框架只要进行简单的配置，就可以完成定时器的任务。

            Timer()创建一个新计时器

    3. 实现线程的第三种方式：FutureTask方式，实现Callable接口 JDK8的新特性
        这种方式实现的线程可以获取线程的返回值
        之前讲解的哪两种方式是无法获取线程返回值的，因为run是void类型

        思考：有些线程执行完毕会得到一个结果，有时我们需要获取这个结果，应该怎么做？
            这时候我们就是用第三种方式：实现Callable接口

    4. 关于Object类中wait和notify方法（生产者和消费者模式！）
        第一： wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法
             wait方法和notify方法不是通过线程对象调用的

        第二：wait方法的用法？
            Object o = new Object();
            o.wait();
            表示：让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒
            不管哪个用了o都会等待suspend，直到被o.notify()方法让o对象上等待的线程唤醒
            还有一个notifyAll()唤醒o对象上处于等待的所有线程


    5. 消费者和生产者模型
        一个线程生产，一个线程消费。最终达到生产和消费平衡：假如生产满了，不生产，消费完了就不能消费了，等待生产
        生产者和消费者的共享对象就是仓库，也就是内存~ 因为是多线程共享问题，因此仓库对象要调用wait和notify方法

        wait和notify方法都是建立在synchronized的基础上的
        o.wait方法会让当前o对象上活动的当前线程进入等待状态，并且释放o对象的锁，因此wait只有一个线程
        o.notify只会通知，不会释放之前占有的o对象的锁


    4. Object类中的wait和notify方法，（生产者和消费者模式）